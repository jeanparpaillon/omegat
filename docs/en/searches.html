<html>
<head>
   <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
   <title>Searches - OmegaT 1.6.0 User Manual</title>
</head>
<body>

<h1>Searches</h1>

<h2>Contents</h2>

<ul type="none">
   <li>1. <a href="#Search_window">Search window</a></li>
   <li>2. <a href="#Search_locations">Search locations</a></li>

   <li>
      3. <a href="#Search_methods">Search methods</a>

      <ul type="none">
         <li>3.1. <a href="#Exact searches">Exact searches</a></li>
         <li>3.2. <a href="#Keyword_searches">Keyword searches</a></li>
      </ul>
   </li>

   <li>4. <a href="#Searching_using_wildcards">Searching using wildcards</a></li>

   <li>
      5. <a href="#Searching_using_regular_expressions">Searching using regular expressions</a>

      <ul>
         <li>5.1. <a href="#Regular_Expressions_to_use_in_searches">Regular Expressions to use in searches</a></li>
         <li>5.2. <a href="#Short_summary_of_regular-expression_constructs">Short summary of regular-expression constructs</a></li>
      </ul>
   </li>
</ul>

<a name="Search_window"></a>
<h2>Search window</h2>

<p>
OmegaT provides a powerful range of search functions.
</p>

<p>
Call up the Search window with <code>Ctrl+F</code> and enter the word or phrase you wish to search for in the "Search for" box.
</p>

<p>
Alternatively, select a word or phrase in the editing field (target text of the active segment) and hit <code>Ctrl+F</code>. The word or phrase is entered in the "Search for" box automatically in this case.
</p>

<p>
Calling up the Search window will always create a new instance of it. You may end up with a number of Search windows if you forget to close them.
</p>

<p>
Searches occur in both the source and target section of a project.
</p>

<a name="Search_locations"></a>
<h2>Search locations</h2>

<p>
Select the location using the check boxes.
</p>

<p>
You can select a number of locations for your search:
</p>

<ul>
   <li>The project only (default setting)</li>
   <li>The project as well as the reference translation memories in /tm/ (check <i>Search TMs</i>)</li>
   <li>A single file or a folder containing a set of files (check <i>Search files</i>)</li>
</ul>

<p>
In the latter case, OmegaT will only search the files it can read (See <a href="fileFormats">Supported File Formats</a>).
</p>

<a name="Search_methods"></a>
<h2>Search methods</h2>

<p>
Select the method using the radio buttons.
</p>

<p>
You can choose between two methods to search:
</p>

<ul>
   <li><strong>Exact search</strong>: Search for segments containing of the string you specified.</li>
   <li><strong>Keyword search</strong>: Search for segments containing all keywords you specified, in any order.</li>
</ul>

<p>
For either of these two methods you can select the following three options:
</p>

<ul>
   <li>
      <strong>Case sensitive</strong>: If selected, the search will be performed
      for the exact string specified; otherwise capitals will be ignored.
   </li>

   <li>
      <strong>Regular expressions</strong>: If selected, the search string will be
      treated as a regular expression (in case of a keyword search it will
      be treated as multiple expressions).
   </li>

   <li>
      <strong>Search TMs</strong>: if selected, all translation memories are included in the search.
   </li>
</ul>

<a name="Exact_searches"></a>
<h2>Exact searches</h2>

<p>
An exact search looks for a phrase, i.e. if several words are entered, they are found only if they occur in exactly the same sequence. Exact searches are similar to an "exact phrase" search in an Internet search engine such as Google.
</p>

<a name="Keyword_searches"></a>
<h2>Keyword searches</h2>

<p>
Select "Keyword search" and enter any number of individual words, separated by spaces and in any order, and OmegaT displays a list of all segments in which all the words occur. Keyword searches are similar to a search "with all of the words" in an Internet search engine such as Google (AND logic).
</p>

<a name="Searching_using_wildcards"></a>
<h2>Searching using wildcards</h2>

<p>
In both exact and keyword searches, the wildcard search characters '<code>*</code>' and '<code>?</code>' can be used. To use wildcards, make sure the option <strong>regular expressions</strong> is not selected, otherwise these characters are interpreted as special regular expression characters.
</p>

<p>
The wildcard character '<code>?</code>' matches any single character, i.e. '<code>b?d</code>' finds instances of '<code>bad</code>' and '<code>bid</code>'. The wildcard character '<code>*</code>' matches any character or number of characters, i.e. '<code>b*d</code>' finds instances of '<code>bad</code>', '<code>bid</code>', '<code>bold</code>' and '<code>band</code>'.
</p>

<p>
If you wish to search for segments containing these characters, you will need to switch on regular expressions, and escape these characters by prepending a backslash ('<code>\</code>') to them, i.e. '<code>x\*y</code>' to find instances of '<code>x*y</code>' and '<code>x\?y</code>' to find instances of '<code>x?y</code>'.
</p>

<a name="Searching_using_regular_expressions"></a>
<h2>Searching using regular expressions</h2>

<p>
A regular expression search is a powerful way to look for instances of a string.
It is similar to a normal search, but allows far more flexibility.
You can find simple tutorials on the web
(<a href="http://www.regular-expressions.info/quickstart.html" title="http://www.regular-expressions.info/quickstart.html" rel="nofollow">http://www.regular-expressions.info/quickstart.html</a>, for example.)
</p>

<a name="Regular_Expressions_to_use_in_searches"></a>
<h3>Regular Expressions to use in searches</h3>

<p>
The regular expressions used in searches are those supported by Java.
If you need more specific information, please consult
<a href="http://java.sun.com/j2se/1.4.2/docs/api/java/util/regex/Pattern.html">
http://java.sun.com/j2se/1.4.2/docs/api/java/util/regex/Pattern.html</a>.
</p>

<a name="Short_summary_of_regular-expression_constructs"></a>
<h4>Short summary of regular-expression constructs</h4>

<table border="0" width="80%" cellpadding="1" cellspacing="0" summary="Regular expression constructs, and what they match">
    <tr bgcolor="#DDEEFF"><th width="10%" align="left" id="construct">Construct&nbsp;</th><th align="left">Matches</th></tr>
    <tr><th>&nbsp;</th></tr>
    <tr align="left"><th colspan="2" id="flags">Flags</th></tr>
    <tr><td><tt>(?i)</tt></td><td>Enables case-insensitive matching (by default, the pattern is case-sensitive).</td></tr>
    <tr><th>&nbsp;</th></tr>
    <tr><th align="left" colspan="2" id="characters">Characters</th></tr>

    <tr><td><strong>x</strong></td><td>The character <strong>x</strong>, except the following...</td></tr>
    <tr><td><tt>\u</tt><strong>hhhh</strong></td><td>The character with hexadecimal&nbsp;value&nbsp;<tt>0x</tt><strong>hhhh</strong></td></tr>
    <tr><td><tt>\t</tt></td><td>The tab character (<tt>'\u0009'</tt>)</td></tr>

    <tr><td><tt>\n</tt></td><td>The newline (line feed) character (<tt>'\u000A'</tt>)</td></tr>
    <tr><td><tt>\r</tt></td><td>The carriage-return character (<tt>'\u000D'</tt>)</td></tr>
    <tr><th>&nbsp;</th></tr>
    <tr align="left"><th colspan="2" id="quot">Quotation</th></tr>

    <tr><td><tt>\</tt></td><td>Nothing, but quotes the following character. This is required if you would like to enter of the metacharacters <code>!$()*+.&lt;&gt;?[\]^{|}</code> to match as themselves.</td></tr>
    <tr><td><tt>\\</tt></td><td>For example, this is the backslash character</td></tr>
    <tr><td><tt>\Q</tt></td><td>Nothing, but quotes all characters until <tt>\E</tt></td></tr>

    <tr><td><tt>\E</tt></td><td>Nothing, but ends quoting started by <tt>\Q</tt></td></tr>
    <tr><th>&nbsp;</th></tr>
    <tr align="left"><th colspan="2" id="classes">Character classes</th></tr>
    <tr><td><tt>[abc]</tt></td><td><tt>a</tt>, <tt>b</tt>, or <tt>c</tt> (simple class)</td></tr>

    <tr><td><tt>[^abc]</tt></td><td>Any character except <tt>a</tt>, <tt>b</tt>, or <tt>c</tt> (negation)</td></tr>
    <tr><td><tt>[a-zA-Z]</tt></td><td><tt>a</tt> through <tt>z</tt> or <tt>A</tt> through <tt>Z</tt>, inclusive (range)</td></tr>

    <tr><th>&nbsp;</th></tr>
    <tr align="left"><th colspan="2" id="predef">Predefined character classes</th></tr>
    <tr><td><tt>.</tt></td><td>Any character (except for line terminators)</td></tr>
    <tr><td><tt>\d</tt></td><td>A digit: <tt>[0-9]</tt></td></tr>
    <tr><td><tt>\D</tt></td><td>A non-digit: <tt>[^0-9]</tt></td></tr>

    <tr><td><tt>\s</tt></td><td>A whitespace character: <tt>[ \t\n\x0B\f\r]</tt></td></tr>
    <tr><td><tt>\S</tt></td><td>A non-whitespace character: <tt>[^\s]</tt></td></tr>
    <tr><td><tt>\w</tt></td><td>A word character: <tt>[a-zA-Z_0-9]</tt></td></tr>
    <tr><td><tt>\W</tt></td><td>A non-word character: <tt>[^\w]</tt></td></tr>

    <tr><th>&nbsp;</th></tr>
    <tr align="left"><th colspan="2" id="bounds">Boundary matchers</th></tr>
    <tr><td><tt>^</tt></td><td>The beginning of a line</td></tr>
    <tr><td><tt>$</tt></td><td>The end of a line</td></tr>
    <tr><td><tt>\b</tt></td><td>A word boundary</td></tr>

    <tr><td><tt>\B</tt></td><td>A non-word boundary</td></tr>
    <tr><th>&nbsp;</th></tr>
    <tr align="left"><th colspan="2" id="greedy">Greedy quantifiers</th></tr>
    <tr><td colspan="2">These will match as much as they can. For example, <code>a+</code> will match <code>aaa</code> in <code>aaabbb</code></td></tr>

    <tr><td><strong>X</strong><tt>?</tt></td><td><strong>X</strong>, once or not at all</td></tr>
    <tr><td><strong>X</strong><tt>*</tt></td><td><strong>X</strong>, zero or more times</td></tr>
    <tr><td><strong>X</strong><tt>+</tt></td><td><strong>X</strong>, one or more times</td></tr>

    <tr><th>&nbsp;</th></tr>
    <tr align="left"><th colspan="2" id="reluc">Reluctant (non-greedy) quantifiers</th></tr>
    <tr><td colspan="2">These will match as little as they can. For example, <code>a+?</code> will match the first <code>a</code> in <code>aaabbb</code></td></tr>
    <tr><td><strong>X</strong><tt>??</tt></td><td><strong>X</strong>, once or not at all</td></tr>

    <tr><td><strong>X</strong><tt>*?</tt></td><td><strong>X</strong>, zero or more times</td></tr>
    <tr><td><strong>X</strong><tt>+?</tt></td><td><strong>X</strong>, one or more times</td></tr>
    <tr><th>&nbsp;</th></tr>
    <tr align="left"><th colspan="2" id="logical">Logical operators</th></tr>

    <tr><td><strong>XY</strong></td><td><strong>X</strong> followed by <strong>Y</strong></td></tr>
    <tr><td><strong>X</strong><tt>|</tt><strong>Y</strong></td><td>Either <strong>X</strong> or <strong>Y</strong></td></tr>

    <tr><td><tt>(</tt><strong>XY</strong><tt>)</tt></td><td><strong>XY</strong> as a single group</td></tr>
</table>

<hr>
<p><a href="legalNotices.html" title="Legal Notices">Legal Notices</a></p>

</body>
</html>