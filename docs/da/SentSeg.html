<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">

<html>
<head>
<title>OmegaT: Sentence Segmentation</title>
<meta http-equiv="content-type" content="text/html; charset=utf-8">
<link rel="stylesheet" type="text/css" href="./omegat.css">
</head>

<body lang="en" dir="LTR">

<div class="navbar-top">

<table border="0" cellpadding="2" width="100%" summary="Navigation Bar">
<tr><td class="toc-link"><a href="./OmegaT.html" title="Table of Contents"><img src="OmegaT.png" border="0" alt="OmegaT Logo"></a></td>
<td class="rel-p">Previous</td>
<td class="nav-link"><a href="./SaveRevComp.html">Save, Revise, Compile</a></td>
<td class="rel-n">Next</td>
<td class="nav-link"><a href="./Searches.html">Searches</a></td></tr>
</table>

</div>

<div class="content">
    
<a name="9"></a>
<h1 align="center" name="9" id="9">Sentence Segmentation</h1>

<ol>
<li><a href="#9.1">Introduction</a></li>
<li><a href="#9.2">Rules Setup</a></li>	
<li><a href="#9.3">Regular Expressions to use in segmentation rules</a></li>
</ol>

<p>After OmegaT has segmented the source file into logical units, for formatted files usually corresponding to paragraphs, it will further segment these blocks into sentences if you don't turn the Sentence Segmenting off. Generally speaking, OmegaT may segment the logical source file blocks into any segments you setup it to. However as <strong>by default</strong> OmegaT segments into sentences, we will call it <strong>sentence</strong> segmenting.</p>

<p>The Sentence Segmentation was built with Segmentation Rules eXchange (SRX) standard in mind, though as of current writing, OmegaT neither supports all SRX features, nor is able to import/export rules defined in SRX format.</p>

<a name="9.1"></a>
<h2 name="9.1" id="9.1">Introduction</h2>

<p>There are two kinds of rules.</p>
<ul>
<li>Break rules break the text into segments.</li>
<li>Exception rules specify what chunks of text should not be separated from others.</li></ul>

<p>Break rule example: <strong>"Did it make sense? I was not sure."</strong> can be segmented as two sentences after the "?". There should be a break rule for "<strong>?</strong>"</p>
<p>Exception rule example: <strong>"Who is afraid of Mrs. Woolf?"</strong> cannot be segmented after the ".". There should be an exception rule for "<strong>Mrs.</strong>".</p>

<p>The predefined break rules should be sufficient for most European languages and Japanese, but we recommend to define more exception rules for the language you translate from, as it is obviosly impossible to predefine all possible exceptions for all possible languages.</p>

<a name="9.2"></a>
<h2 name="9.2" id="9.2">Rules Setup</h2>

<p>In order to setup the rules, select <strong>Options &gt; Segmentation...</strong> from the main menu. Note that you may change segmentation options only when there is no project open, because of the possible conflicts between the changed segmentation rules and segmentation in use in the opened project.</p>

<a name="9.2.1"></a>
<h3 name="9.2.1" id="9.2.1">Sets of Rules</h3>

<p>All the segmentation rule sets with a matching Language Pattern are applied 
in the given order of priority, so rules for specific language should be higher 
than default ones.</p>

<p>For example, rules for Canadian French (FR-CA) should be higher than rules 
for French (FR.*), and higher than Default (.*) ones.</p>
 
<p>Then while translating from Canadian French your project will use the rules defined for this language, the rules for French, and the Default rules in a correct order.</p>

<p>In order to create an empty set of rules, click <strong>Add</strong> in the upper half of the dialog. An empty line appears at the bottom of a table. Change the name of the rule set and the language pattern. Syntax of the language pattern conforms to regular expression syntax. See <a href="#9.3.1">Short summary of regular-expression constructs</a> below.</p>

<p>If your set of rules handles a language-country pair, we advise you to move it atop using <strong>Move Up</strong> button.</p>

<p>In order to edit a set of rules, simply click on it in a table, the rules of the set will appear in the bottom half of the window.</p>

<p>The Break/Exception checkbox determines whether it is a break rule (checkbox set) or an exception rule (checkbox unset). Two regular expressions Before and After specify what must be before and after some position so that it qualifies for exception rule or for break rule.</p>

<p>The process of segmenting may be simplified to the following. Imagine a cursor moving from after the first to before the last symbol of the text. For each cursor position we take each rule in the given order and try to apply the <strong>Before</strong> pattern to all the text that is on the left of a cursor and the <strong>After</strong> pattern to the text on the right so that they touch the cursor.
<br>If the application of some rule is successful, for exception rules we do nothing but stop examining more rules, and for break rules we take the text on the left as a separate segment, for each position of the text (by position we understand a cursor between two symbols).</p>

<a name="9.2.2"></a>
<h3 name="9.2.2" id="9.2.2">Simple examples</h3>

<p><dl><dt><strong>Aim:</strong> to set a segment after a "\." (period) and before a space</dt>
<dd><code>Before: \. After: \s</code><br>
<strong>Note:</strong> "\." means the character "."<br>
"\s" means any white space character</dd>
<dt><strong>Aim:</strong> to not set a segment after "Mr."</dt>
<dd>Before: Mr\. After: \s<br>
<strong>Note:</strong> Don't forget to leave the rule box <strong>unchecked</strong></dd>
<dt><strong>Aim:</strong> to set a segment after "。" (Japanese period)</dt>
<dd><code>Before: 。 After: (empty)</code><br>
<strong>Note:</strong> You can leave a field empty</dd></dl>
The first two examples are taken from the <strong>Default</strong> rules.</p>

<a name="9.3"></a>
<h2 name="9.3" id="9.3">Regular Expressions to use in segmentation rules</h2>

<p>The segmentation rules themselves are represented using regular expressions. This allows for maximum flexibility in the definition of the rules and conforms to SRX.</p>

<a name="9.3.1"></a>
<h3 name="9.3.1" id="9.3.1">Short summary of regular-expression constructs</h3>

<p>These are not the only constructs you may use in OmegaT segmentation rules, but rather the most commonly used. OmegaT supports all the regular expression features as described in SRX standard.</p>

<table border="0" width="80%" cellpadding="1" cellspacing="0" summary="Regular expression constructs, and what they match">
<tr bgcolor="#DDEEFF"><th width="10%" align="left" id="construct">Construct&nbsp;</th><th align="left">Matches</th></tr>
<tr><th>&nbsp;</th></tr>
<tr align="left"><th colspan="2" id="flags">Flags</th></tr>
<tr><td><tt>(?i)</tt></td><td>Enables case-insensitive matching (by default, the pattern is case-sensitive).</td></tr>
<tr><th>&nbsp;</th></tr>
<tr><th align="left" colspan="2" id="characters">Characters</th></tr>
<tr><td><strong>x</strong></td><td>The character <strong>x</strong>, except the following...</td></tr>
<tr><td><tt>\u</tt><strong>hhhh</strong></td><td>The character with hexadecimal&nbsp;value&nbsp;<tt>0x</tt><strong>hhhh</strong></td></tr>
<tr><td><tt>\t</tt></td><td>The tab character (<tt>'\u0009'</tt>)</td></tr>
<tr><td><tt>\n</tt></td><td>The newline (line feed) character (<tt>'\u000A'</tt>)</td></tr>
<tr><td><tt>\r</tt></td><td>The carriage-return character (<tt>'\u000D'</tt>)</td></tr>
<tr><th>&nbsp;</th></tr>
<tr align="left"><th colspan="2" id="quot">Quotation</th></tr>
<tr><td><tt>\</tt></td><td>Nothing, but quotes the following character. This is required if you would like to enter of the metacharacters <code>!$()*+.&lt;&gt;?[\]^{|}</code> to match as themselves.</td></tr>
<tr><td><tt>\\</tt></td><td>For example, this is the backslash character</td></tr>
<tr><td><tt>\Q</tt></td><td>Nothing, but quotes all characters until <tt>\E</tt></td></tr>
<tr><td><tt>\E</tt></td><td>Nothing, but ends quoting started by <tt>\Q</tt></td></tr>
<tr><th>&nbsp;</th></tr>
<tr align="left"><th colspan="2" id="classes">Character classes</th></tr>
<tr><td><tt>[abc]</tt></td><td><tt>a</tt>, <tt>b</tt>, or <tt>c</tt> (simple class)</td></tr>
<tr><td><tt>[^abc]</tt></td><td>Any character except <tt>a</tt>, <tt>b</tt>, or <tt>c</tt> (negation)</td></tr>
<tr><td><tt>[a-zA-Z]</tt></td><td><tt>a</tt> through <tt>z</tt> or <tt>A</tt> through <tt>Z</tt>, inclusive (range)</td></tr>
<tr><th>&nbsp;</th></tr>
<tr align="left"><th colspan="2" id="predef">Predefined character classes</th></tr>
<tr><td><tt>.</tt></td><td>Any character (except for line terminators)</td></tr>
<tr><td><tt>\d</tt></td><td>A digit: <tt>[0-9]</tt></td></tr>
<tr><td><tt>\D</tt></td><td>A non-digit: <tt>[^0-9]</tt></td></tr>
<tr><td><tt>\s</tt></td><td>A whitespace character: <tt>[ \t\n\x0B\f\r]</tt></td></tr>
<tr><td><tt>\S</tt></td><td>A non-whitespace character: <tt>[^\s]</tt></td></tr>
<tr><td><tt>\w</tt></td><td>A word character: <tt>[a-zA-Z_0-9]</tt></td></tr>
<tr><td><tt>\W</tt></td><td>A non-word character: <tt>[^\w]</tt></td></tr>
<tr><th>&nbsp;</th></tr>
<tr align="left"><th colspan="2" id="bounds">Boundary matchers</th></tr>
<tr><td><tt>^</tt></td><td>The beginning of a line</td></tr>
<tr><td><tt>$</tt></td><td>The end of a line</td></tr>
<tr><td><tt>\b</tt></td><td>A word boundary</td></tr>
<tr><td><tt>\B</tt></td><td>A non-word boundary</td></tr>
<tr><th>&nbsp;</th></tr>
<tr align="left"><th colspan="2" id="greedy">Greedy quantifiers</th></tr>
<tr><td colspan="2">These will match as much as they can. For example, <code>a+</code> will match <code>aaa</code> in <code>aaabbb</code></td></tr>
<tr><td><strong>X</strong><tt>?</tt></td><td><strong>X</strong>, once or not at all</td></tr>
<tr><td><strong>X</strong><tt>*</tt></td><td><strong>X</strong>, zero or more times</td></tr>
<tr><td><strong>X</strong><tt>+</tt></td><td><strong>X</strong>, one or more times</td></tr>
<tr><th>&nbsp;</th></tr>
<tr align="left"><th colspan="2" id="reluc">Reluctant (non-greedy) quantifiers</th></tr>
<tr><td colspan="2">These will match as little as they can. For example, <code>a+?</code> will match the first <code>a</code> in <code>aaabbb</code></td></tr>
<tr><td><strong>X</strong><tt>??</tt></td><td><strong>X</strong>, once or not at all</td></tr>
<tr><td><strong>X</strong><tt>*?</tt></td><td><strong>X</strong>, zero or more times</td></tr>
<tr><td><strong>X</strong><tt>+?</tt></td><td><strong>X</strong>, one or more times</td></tr>
<tr><th>&nbsp;</th></tr>
<tr align="left"><th colspan="2" id="logical">Logical operators</th></tr>
<tr><td><strong>XY</strong></td><td><strong>X</strong> followed by <strong>Y</strong></td></tr>
<tr><td><strong>X</strong><tt>|</tt><strong>Y</strong></td><td>Either <strong>X</strong> or <strong>Y</strong></td></tr>
<tr><td><tt>(</tt><strong>XY</strong><tt>)</tt></td><td><strong>XY</strong> as a single group</td></tr></table>

</div>

<div class="navbar-bottom">

<table border="0" cellpadding="2" width="100%" summary="Navigation Bar">
<tr><td class="toc-link"><a href="./OmegaT.html" title="Table of Contents"><img src="OmegaT.png" border="0" alt="OmegaT Logo"></a></td>
<td class="rel-p">Previous</td>
<td class="nav-link"><a href="./SaveRevComp.html">Save, Revise, Compile</a></td>
<td class="rel-n">Next</td>
<td class="nav-link"><a href="./Searches.html">Searches</a></td></tr>
</table>

</div>

</body>
</html>